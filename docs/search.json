[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Sai Ram Kuchana",
    "section": "",
    "text": "Linkedin\n  \n  \n    \n     Email\n  \n\n  \n  \nHi, I’m Ram!\nI have newly developed passion for Data Science and Coding. Here, I post my projects whenever i have done something new and got time."
  },
  {
    "objectID": "index.html#projects",
    "href": "index.html#projects",
    "title": "Sai Ram Kuchana",
    "section": "Projects",
    "text": "Projects\n\n\n\n\n\n\n\n\n\n\nTraining an AI to play a game using reinforcement learning\n\n\n\nPYTHON\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGenerating parse trees and extracting noun phrases\n\n\n\nNLTK\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing SQL to find the missing packages in the mail delivery service’s database\n\n\n\nSQL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSoft deletions, views, and triggers in the context of a museum’s database\n\n\n\nSQL\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNearest neighbor for handwritten digit recognition\n\n\n\nNumPy\n\n\nMatplotlib\n\n\nscikit-learn\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html",
    "href": "projects/SQLMuseum/mfa.html",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "",
    "text": "In this project, we will explore the concepts of soft deletions, views, and triggers in the context of the Museum of Fine Arts (MFA). The MFA is a century-old museum housing numerous historical and contemporary artifacts and artworks. It manages its extensive collection through the MFA database, which tracks thousands of items. However, for the purpose of this project, we will work with a subset of the database containing only ten items in the collections table.\n\n\n\n\n\nER diagram of the MFA database\n\n\nThe Schema of the MFA database is shown above. The collections table contains the following columns:\n\nid, which is the ID of the table that serves as the primary key\ntitle, which is the name of the art piece\naccession_number, which is a unique ID used by the museum internally\nacquired, which indicates when the art was acquired\n\nLet us now establish the SQLite connection to the database using DBI package.\n\n\nCode\nlibrary(DBI)\ncon &lt;- dbConnect(RSQLite::SQLite(), \"mfa.db\") # establish SQLite connection to the database\n\n\nThe data of the collections table is as follows:\n\n\nCode\nSELECT * FROM \"collections\";\n\n\n\nDisplaying records 1 - 10\n\n\nid\ntitle\naccession_number\nacquired\n\n\n\n\n1\nProfusion of flowers\n56.257\n1956-04-12\n\n\n2\nFarmers working at dawn\n11.6152\n1911-08-03\n\n\n3\nSpring outing\n14.76\n1914-01-08\n\n\n4\nImaginative landscape\n56.496\nNA\n\n\n5\nPeonies and butterfly\n06.1899\n1906-01-01\n\n\n6\nTile Lunette\n06.2437\n1906-11-08\n\n\n7\nStatuette of a shrew\n01.105\n1901-02-11\n\n\n8\nCountry road with culvert\n76.431\nNA\n\n\n9\nFamily of acrobats\n1974.352\n1933-03-30\n\n\n10\nBacchic scene with minotaur\n1974.379\n1933-05-18"
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#schema",
    "href": "projects/SQLMuseum/mfa.html#schema",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "",
    "text": "ER diagram of the MFA database\n\n\nThe Schema of the MFA database is shown above. The collections table contains the following columns:\n\nid, which is the ID of the table that serves as the primary key\ntitle, which is the name of the art piece\naccession_number, which is a unique ID used by the museum internally\nacquired, which indicates when the art was acquired\n\nLet us now establish the SQLite connection to the database using DBI package.\n\n\nCode\nlibrary(DBI)\ncon &lt;- dbConnect(RSQLite::SQLite(), \"mfa.db\") # establish SQLite connection to the database\n\n\nThe data of the collections table is as follows:\n\n\nCode\nSELECT * FROM \"collections\";\n\n\n\nDisplaying records 1 - 10\n\n\nid\ntitle\naccession_number\nacquired\n\n\n\n\n1\nProfusion of flowers\n56.257\n1956-04-12\n\n\n2\nFarmers working at dawn\n11.6152\n1911-08-03\n\n\n3\nSpring outing\n14.76\n1914-01-08\n\n\n4\nImaginative landscape\n56.496\nNA\n\n\n5\nPeonies and butterfly\n06.1899\n1906-01-01\n\n\n6\nTile Lunette\n06.2437\n1906-11-08\n\n\n7\nStatuette of a shrew\n01.105\n1901-02-11\n\n\n8\nCountry road with culvert\n76.431\nNA\n\n\n9\nFamily of acrobats\n1974.352\n1933-03-30\n\n\n10\nBacchic scene with minotaur\n1974.379\n1933-05-18"
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#problem-1-soft-deleting-the-artworks",
    "href": "projects/SQLMuseum/mfa.html#problem-1-soft-deleting-the-artworks",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "2.1 Problem 1: Soft deleting the artworks",
    "text": "2.1 Problem 1: Soft deleting the artworks\n\n\n\n\n\n\nImplement a soft deletion of items in the collections table, where a log of sold artworks is kept in the column named “deleted” instead of completely removing them from the table, so that the records of artworks in the collection are not lost. The “deleted” column in the collections table must have a value of 0 for the available items for sale and a value of 1 for the items that have been sold. Imagine the artworks “Farmers Working at Dawn” and “Tile Lunette” were sold, and implement this idea of soft deletion on them."
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#problem-2-view-that-shows-only-available-artworks",
    "href": "projects/SQLMuseum/mfa.html#problem-2-view-that-shows-only-available-artworks",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "2.2 Problem 2: View that shows only available artworks",
    "text": "2.2 Problem 2: View that shows only available artworks\n\n\n\n\n\n\nCreate a view named current_collections using all the columns of the collections table except the “deleted” column, so that the view can be used to display only the information about the artworks that are available for sale."
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#problem-3-trigger-that-soft-deletes-the-artworks",
    "href": "projects/SQLMuseum/mfa.html#problem-3-trigger-that-soft-deletes-the-artworks",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "2.3 Problem 3: Trigger that soft deletes the artworks",
    "text": "2.3 Problem 3: Trigger that soft deletes the artworks\n\n\n\n\n\n\nSince data in the view cannot be modified directly, create a trigger on the current_collections view that soft deletes the data from the underlying collections table, as per the idea of soft deletion discussed above. The trigger must be activated when any data is attempted to be deleted from the view. Demonstrate this trigger by selling all the artworks that have no acquired date."
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#problem-4-trigger-that-reverses-the-soft-deletion-of-artworks",
    "href": "projects/SQLMuseum/mfa.html#problem-4-trigger-that-reverses-the-soft-deletion-of-artworks",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "2.4 Problem 4: Trigger that reverses the soft deletion of artworks",
    "text": "2.4 Problem 4: Trigger that reverses the soft deletion of artworks\n\n\n\n\n\n\nImagine the items sold in the task 3 are rebought. Now, create a trigger on the current_collections view that reverses the soft deletion, i.e., setting the corresponding row’s deleted value to 0 in the underlying collections table to indicate that the items are again available. The trigger must be executed when any soft-deleted data is attempted to be inserted into the current_collections view."
  },
  {
    "objectID": "projects/SQLMuseum/mfa.html#problem-5-trigger-that-inserts-new-artworks",
    "href": "projects/SQLMuseum/mfa.html#problem-5-trigger-that-inserts-new-artworks",
    "title": "2. Soft deletions, views, and triggers in the context of a museum’s database",
    "section": "2.5 Problem 5: Trigger that inserts new artworks",
    "text": "2.5 Problem 5: Trigger that inserts new artworks\n\n\n\n\n\n\nCreate a trigger on the current_collections view that inserts new data into the underlying collections table when any new data is attempted to be inserted into the view. Demonstrate this trigger by buying new artworks ‘Adoration of the Magi’ (accession_number: 1971.71, acquired: 2022-01-11) and ‘Agony in the Garden’ (accession_number: 68.206, acquired: 2022-05-01)."
  },
  {
    "objectID": "projects/SQLPackages/packages.html",
    "href": "projects/SQLPackages/packages.html",
    "title": "1. Using SQL to find the missing packages in the mail delivery service’s database",
    "section": "",
    "text": "Imagine you are a mail clerk for the city of Boston who oversees the delivery of mail across the city. For the most part, all packages sent are eventually delivered. However, every once in while, a mystery lands on your desk: a missing package! For each customer that comes to you with a report of a missing package, your task is to help each customer find their missing package and answer their relevant questions using just the information in the mail delivery service’s database, packages.db, which contains data on the transit of packages around the city.\nThe specific problems to solve and the schema of the database are described below.\n\n\nThe first report of a missing package comes from Anneke. Anneke walks up to your counter and tells you the following:\n\n\n\n\n\n\nClerk, my name’s Anneke. I live over at 900 Somerville Avenue. Not long ago, I sent out a special letter. It’s meant for my friend Varsha. She’s starting a new chapter of her life at 2 Finnegan Street, uptown. (That address, let me tell you: it was a bit tricky to get right the first time.) The letter is a congratulatory note—a cheery little paper hug from me to her, to celebrate this big move of hers. Can you check if it’s made its way to her yet?\n\n\n\nYour job is to find out:\n\nAt what type of address did the Lost Letter end up?\nAt what address did the Lost Letter end up?\n\n\n\n\nThe second report of a missing package comes from a mysterious fellow from out of town. They walk up to your counter and tell you the following:\n\n\n\n\n\n\nGood day to you, deliverer of the mail. You might remember that not too long ago I made my way over from the town of Fiftyville. I gave a certain box into your reliable hands and asked you to keep things low. My associate has been expecting the package for a while now. And yet, it appears to have grown wings and flown away. Ha! Any chance you could help clarify this mystery? Afraid there’s no “From” address. It’s the kind of parcel that would add a bit more… quack to someone’s bath times, if you catch my drift.\n\n\n\nYour job is to find out:\n\nAt what type of address did the Devious Delivery end up?\nWhat were the contents of the Devious Delivery?\n\n\n\n\nThe third report of a missing package comes from a grandparent who lives down the street from the post office. They approach your counter and tell you the following:\n\n\n\n\n\n\nOh, excuse me, Clerk. I had sent a mystery gift, you see, to my wonderful granddaughter, off at 728 Maple Place. That was about two weeks ago. Now the delivery date has passed by seven whole days and I hear she still waits, her hands empty and heart filled with anticipation. I’m a bit worried wondering where my package has gone. I cannot for the life of me remember what’s inside, but I do know it’s filled to the brim with my love for her. Can we possibly track it down so it can fill her day with joy? I did send it from my home at 109 Tileston Street.\n\n\n\nYour job is to find out:\n\nWhat are the contents of the Forgotten Gift?\nWho has the Forgotten Gift?"
  },
  {
    "objectID": "projects/SQLPackages/packages.html#problem-1-the-missing-letter",
    "href": "projects/SQLPackages/packages.html#problem-1-the-missing-letter",
    "title": "1. Using SQL to find the missing packages in the mail delivery service’s database",
    "section": "",
    "text": "The first report of a missing package comes from Anneke. Anneke walks up to your counter and tells you the following:\n\n\n\n\n\n\nClerk, my name’s Anneke. I live over at 900 Somerville Avenue. Not long ago, I sent out a special letter. It’s meant for my friend Varsha. She’s starting a new chapter of her life at 2 Finnegan Street, uptown. (That address, let me tell you: it was a bit tricky to get right the first time.) The letter is a congratulatory note—a cheery little paper hug from me to her, to celebrate this big move of hers. Can you check if it’s made its way to her yet?\n\n\n\nYour job is to find out:\n\nAt what type of address did the Lost Letter end up?\nAt what address did the Lost Letter end up?"
  },
  {
    "objectID": "projects/SQLPackages/packages.html#problem-2-the-devious-delivery",
    "href": "projects/SQLPackages/packages.html#problem-2-the-devious-delivery",
    "title": "1. Using SQL to find the missing packages in the mail delivery service’s database",
    "section": "",
    "text": "The second report of a missing package comes from a mysterious fellow from out of town. They walk up to your counter and tell you the following:\n\n\n\n\n\n\nGood day to you, deliverer of the mail. You might remember that not too long ago I made my way over from the town of Fiftyville. I gave a certain box into your reliable hands and asked you to keep things low. My associate has been expecting the package for a while now. And yet, it appears to have grown wings and flown away. Ha! Any chance you could help clarify this mystery? Afraid there’s no “From” address. It’s the kind of parcel that would add a bit more… quack to someone’s bath times, if you catch my drift.\n\n\n\nYour job is to find out:\n\nAt what type of address did the Devious Delivery end up?\nWhat were the contents of the Devious Delivery?"
  },
  {
    "objectID": "projects/SQLPackages/packages.html#problem-3-the-forgotten-gift",
    "href": "projects/SQLPackages/packages.html#problem-3-the-forgotten-gift",
    "title": "1. Using SQL to find the missing packages in the mail delivery service’s database",
    "section": "",
    "text": "The third report of a missing package comes from a grandparent who lives down the street from the post office. They approach your counter and tell you the following:\n\n\n\n\n\n\nOh, excuse me, Clerk. I had sent a mystery gift, you see, to my wonderful granddaughter, off at 728 Maple Place. That was about two weeks ago. Now the delivery date has passed by seven whole days and I hear she still waits, her hands empty and heart filled with anticipation. I’m a bit worried wondering where my package has gone. I cannot for the life of me remember what’s inside, but I do know it’s filled to the brim with my love for her. Can we possibly track it down so it can fill her day with joy? I did send it from my home at 109 Tileston Street.\n\n\n\nYour job is to find out:\n\nWhat are the contents of the Forgotten Gift?\nWho has the Forgotten Gift?"
  },
  {
    "objectID": "projects/NimGame/NimGame.html",
    "href": "projects/NimGame/NimGame.html",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "",
    "text": "In this project, we will build an AI to learn the strategy for playing the game Nim through reinforcement learning. In particular, we will explore one of the models of reinforcement learning called Q-learning. But first, let’s look at how the Nim game is played."
  },
  {
    "objectID": "projects/NimGame/NimGame.html#defining-the-nim-game",
    "href": "projects/NimGame/NimGame.html#defining-the-nim-game",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "3.1 Defining the Nim game",
    "text": "3.1 Defining the Nim game\nThe Nim class defines how a Nim game is played. An object of the Nim class is initialized to keep track of the piles, the current player, and the winner of the game. The available_actions method returns a set of all the available actions for a given state. The move method checks the validity of a player’s move/action, updates the number of objects in the piles according to the move, switches the player’s turn using the switch_player and other_player methods, and finally checks for a winner.\n\n\nCode\n# Import the required modules\n\nimport math\nimport random\nimport time\n\n\nclass Nim():\n    \"\"\" Class to define the Nim game itself \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize game board.\n        Each game board has\n            - `piles`: a list of how many objects remain in each pile\n            - `player`: 0 or 1 to indicate which player's turn\n            - `winner`: None, 0, or 1 to indicate who the winner is\n        \"\"\"\n        initial=[1, 3, 5, 7]\n        self.piles = initial.copy()\n        self.player = 0\n        self.winner = None\n\n    @classmethod\n    def available_actions(cls, piles):\n        \"\"\"\n        Nim.available_actions(piles) takes a `piles` list aka `state` as input\n        and returns all of the available actions `(i, j)` in that state.\n\n        Action `(i, j)` represents the action of removing `j` items\n        from pile `i` (where piles are 0-indexed).\n        \"\"\"\n        actions = set()\n        for i, pile in enumerate(piles):\n            for j in range(1, pile + 1):\n                actions.add((i, j))\n        return actions\n\n    @classmethod\n    def other_player(cls, player):\n        \"\"\"\n        Nim.other_player(player) returns the player that is not\n        `player`. Assumes `player` is either 0 or 1.\n        \"\"\"\n        return 0 if player == 1 else 1\n\n    def switch_player(self):\n        \"\"\"\n        Switch the current player to the other player.\n        \"\"\"\n        self.player = Nim.other_player(self.player)\n\n    def move(self, action):\n        \"\"\"\n        Make the move aka `action` for the current player.\n        `action` must be a tuple `(i, j)`.\n        \"\"\"\n        pile, count = action\n\n        # Check for the validity of the move\n        if self.winner is not None:\n            raise Exception(\"Game already won\")\n        elif pile &lt; 0 or pile &gt;= len(self.piles):\n            raise Exception(\"Invalid pile\")\n        elif count &lt; 1 or count &gt; self.piles[pile]:\n            raise Exception(\"Invalid number of objects\")\n\n        # Update pile\n        self.piles[pile] -= count\n        \n        # Switch the player\n        self.switch_player()\n\n        # Check for a winner\n        if all(pile == 0 for pile in self.piles):\n            self.winner = self.player"
  },
  {
    "objectID": "projects/NimGame/NimGame.html#defining-the-nimai",
    "href": "projects/NimGame/NimGame.html#defining-the-nimai",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "3.2 Defining the NimAI",
    "text": "3.2 Defining the NimAI\nThe NimAI class defines the AI where the Q-learning algorithm is implemented. An object of the NimAI class is initialized with an empty q_value dictionary, and default values of 0.5 and 0.1 for alpha and epsilon respectively. The q_value dictionary keeps track of all Q-values of (state, action) pairs learned by the AI. Alpha is used in the Q-learning formula, and epsilon is used for action selection.\nThe update method updates the Q-value of an action in a state. It takes inputs: old_state (the state where the action is taken), action (the action taken in the old state), reward (the immediate reward for that action in that state), and new_state (the state resulting from taking that action). The method then implements Q-learning by retrieving the current Q-value using get_q_value, determining the best possible future rewards with best_future_reward, and updating the Q-value using update_q_value.\nLastly, the choose_action method selects an action for a given state based on an epsilon-greedy algorithm. The epsilon-greedy algorithm allows the AI to explore other actions in a state to maximize future rewards. With probability epsilon, the AI chooses a random action (explore), and with probability (1 - epsilon), it chooses the action with the highest Q-value (exploit). This balance between exploration and exploitation helps in improving the AI’s performance over time.\n\n\nCode\nclass NimAI():\n    \"\"\" Class to define the AI \"\"\"\n    def __init__(self, alpha=0.5, epsilon=0.1):\n        \"\"\"\n        Initialize AI with an empty Q-learning dictionary,\n        an alpha (learning) rate, and an epsilon rate.\n\n        The Q-learning dictionary maps `(state, action)` pairs to a Q-value (a number).\n         - `state` is a tuple of remaining piles, e.g. (1, 1, 4, 4)\n         - `action` is a tuple `(i, j)` for an action\n        \"\"\"\n        self.q_value = {}\n        self.alpha = alpha\n        self.epsilon = epsilon\n\n    def update(self, old_state, action, new_state, reward):\n        \"\"\"\n        Update Q-learning model, given an old state, an action taken\n        in that state, a new resulting state, and the reward received\n        from taking that action.\n        \"\"\"\n        old = self.get_q_value(old_state, action)\n        best_future = self.best_future_reward(new_state)\n        self.update_q_value(old_state, action, old, reward, best_future)\n\n    def get_q_value(self, state, action):\n        \"\"\"\n        Return the Q-value for the state `state` and the action `action`.\n        If no Q-value exists yet in `self.q`, return 0.\n        \"\"\"\n        # If there is a Q-value for current (state, action)\n        # already in `self.q`, return it\n        if (tuple(state), action) in self.q_value:\n            return self.q_value[(tuple(state), action)]\n\n        # If current (state action) is not explored yet, Q-value is 0\n        return 0\n\n    def update_q_value(self, state, action, old_q, reward, future_rewards):\n        \"\"\"\n        Update the Q-value for the state `state` and the action `action`\n        given the previous Q-value `old_q`, a current reward `reward`,\n        and an estiamte of future rewards `future_rewards`.\n\n        Use the formula:\n\n        Q(s, a) &lt;- old value estimate + alpha * (new value estimate - old value estimate)\n\n        where `old value estimate` is the previous Q-value,\n        `alpha` is the learning rate, and `new value estimate`\n        is the sum of the current reward and estimated future rewards.\n        \"\"\"\n        # Calculate and get constants\n        new_value_estimate = reward + future_rewards\n        alpha = self.alpha\n\n        # Update Q-value according to the formula\n        self.q_value[(tuple(state), action)] = old_q + alpha * (new_value_estimate - old_q)\n\n    def best_future_reward(self, state):\n        \"\"\"\n        Given a state `state`, consider all possible `(state, action)`\n        pairs available in that state and return the maximum of all\n        of their Q-values.\n\n        Use 0 as the Q-value if a `(state, action)` pair has no\n        Q-value in `self.q`. If there are no available actions in\n        `state`, return 0.\n        \"\"\"\n        possible_actions = Nim.available_actions(state)\n\n        # Corner case where there is no possible actions\n        if len(possible_actions) == 0:\n            return 0\n\n        # Initialize cur_reward to as low as possible to make sure\n        # There are better actions than None\n        reward = -math.inf\n\n        for action in possible_actions:\n            # If action is in self.q and the reward of the action \n            # is better than current reward, update reward\n            cur_reward = self.get_q_value(state, action)\n            if cur_reward &gt; reward:\n                reward = cur_reward\n\n        return reward\n\n    def choose_action(self, state, epsilon=True):\n        \"\"\"\n        Given a state `state`, return an action `(i, j)` to take.\n\n        If `epsilon` is `False`, then return the best action\n        available in the state (the one with the highest Q-value,\n        using 0 for pairs that have no Q-values).\n\n        If `epsilon` is `True`, then with probability\n        `self.epsilon` choose a random available action,\n        otherwise choose the best action available.\n\n        If multiple actions have the same Q-value, any of those\n        options is an acceptable return value.\n        \"\"\"\n        # Initialize all possible actions\n        # Set highest Q-value to as low as possible to make sure\n        # some action has better  Q-value than the initial best action of None\n        possible_actions = Nim.available_actions(state)\n        highest_q = -math.inf \n        best_action = None    \n\n        # Iterate all possible actions and compare the Q-value of each\n        for action in possible_actions:\n            current_q = self.get_q_value(state, action)\n            # If current action is better, update current Q-value and best_action\n            if current_q &gt; highest_q:\n                highest_q = current_q\n                best_action = action\n\n        # If epsilon is true, take random action according to probabilities\n        # Exploration vs Exploitation\n        if epsilon:\n            # For self.epsilon chance, take random action\n            # For 1 - self.epsilon chance, take best action\n            action_weights = [self.epsilon / len(possible_actions) if action != best_action else\n                                (1 - self.epsilon) for action in possible_actions]\n\n            best_action = random.choices(list(possible_actions), weights=action_weights, k=1)[0]\n\n        return best_action"
  },
  {
    "objectID": "projects/NimGame/NimGame.html#defining-the-training",
    "href": "projects/NimGame/NimGame.html#defining-the-training",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "3.3 Defining the training",
    "text": "3.3 Defining the training\nThe train function trains the AI by making it play against itself ‘n’ times. It sets up the game using Nim class, trains the AI using NimAI class, and finally returns the trained AI.\n\n\nCode\ndef train(n):\n    \"\"\"\n    Train an AI by playing `n` games against itself.\n    \"\"\"\n\n    player = NimAI()\n\n    # Play 'n' games\n    for i in range(n):\n        \n        # print the phrase only for the first and last 10 games when training is &gt; 50 games\n        if i+1 &lt;= 10 or n &lt;=50:\n            print(f\"Playing training game {i + 1}\")\n            \n        elif len(range(n)) - i &lt;= 10 :\n            if len(range(n)) - i == 10:\n                print(\"*\\n\"*5 , end='')\n            print(f\"Playing training game {i + 1}\")\n\n\n        #initialize the game\n        game = Nim()\n\n        # Keep track of last move made by either player\n        last = {\n            0: {\"state\": None, \"action\": None},\n            1: {\"state\": None, \"action\": None}\n        }\n\n        # Game loop\n        while True:\n\n            # Keep track of current state and action\n            state = game.piles.copy()\n            action = player.choose_action(game.piles)\n\n            # Keep track of last state and action\n            last[game.player][\"state\"] = state\n            last[game.player][\"action\"] = action\n\n            # Make move\n            game.move(action)\n            new_state = game.piles.copy()\n\n            # When game is over, update Q-value with rewards\n            if game.winner is not None:\n\n                # update the state and action that resulted in loss with reward value -1\n                player.update(state, action, new_state, -1)\n\n                # update the state and action that resulted in win with reward value 1\n                player.update(last[game.player][\"state\"], last[game.player][\"action\"], new_state, 1)\n                \n                break\n\n            # If game is continuing, update Q-value with no rewards i.e. 0\n            elif last[game.player][\"state\"] is not None:\n\n                player.update(last[game.player][\"state\"],last[game.player][\"action\"], new_state, 0)\n\n    print(\"\\nDone training\")\n\n    # Return the trained AI\n    return player"
  },
  {
    "objectID": "projects/NimGame/NimGame.html#defining-the-play-between-a-human-and-the-nimai",
    "href": "projects/NimGame/NimGame.html#defining-the-play-between-a-human-and-the-nimai",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "3.4 Defining the play between a human and the NimAI",
    "text": "3.4 Defining the play between a human and the NimAI\nThe play function sets up a Nim game between a human and the AI using the NimAI object.\n\n\nCode\ndef play(nim_ai, human_player=None):\n    \"\"\"\n    Play human game against the AI.\n    `human_player` can be set to 0 or 1 to specify whether\n    human player moves first or second.\n    \"\"\"\n\n    # If no player order set, choose human's order randomly\n    if human_player is None:\n        human_player = random.randint(0, 1)\n\n    # Create new game\n    game = Nim()\n\n    # Game loop\n    while True:\n\n        # Print contents of piles\n        print()\n        print(\"Piles:\")\n        for i, pile in enumerate(game.piles):\n            print(f\"Pile {i}: {pile}\")\n        print()\n\n        # Compute current available actions\n        available_actions = Nim.available_actions(game.piles)\n        time.sleep(1)\n\n        # Let human make a move\n        if game.player == human_player:\n            print(\"Your Turn\")\n            while True:\n                pile = int(input(\"Choose Pile: \"))\n                count = int(input(\"Choose Count: \"))\n                if (pile, count) in available_actions:\n                    break\n                print(\"Invalid move, try again.\")\n\n        # Have AI make a move \n        else:\n            print(\"AI's Turn\")\n            pile, count = nim_ai.choose_action(game.piles, epsilon=False)\n            print(f\"AI chose to take {count} object(s) from pile {pile}.\")\n\n        # updates the objects in each pile after taking action; Switches player; Checks for winner\n        game.move((pile, count))\n\n        # Checks for winner and ends the game\n        if game.winner is not None:\n            print()\n            print(\"GAME OVER\")\n            winner = \"Human\" if game.winner == human_player else \"AI\"\n            print(f\"Winner is {winner}\")\n            return"
  },
  {
    "objectID": "projects/NimGame/NimGame.html#human-vs-untrained-ai",
    "href": "projects/NimGame/NimGame.html#human-vs-untrained-ai",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "4.1 Human Vs Untrained AI",
    "text": "4.1 Human Vs Untrained AI\n\n\nCode\nuntrained_ai = train(0)\n\n\nDone training\n\n\nCode\nplay(untrained_ai)\n\n\nPiles:\nPile 0: 1\nPile 1: 3\nPile 2: 5\nPile 3: 7\n\nYour Turn\nChoose Pile: 2\nChoose Count: 5\n\nPiles:\nPile 0: 1\nPile 1: 3\nPile 2: 0\nPile 3: 7\n\nAI's Turn\nAI chose to take 1 object(s) from pile 0.\n\nPiles:\nPile 0: 0\nPile 1: 3\nPile 2: 0\nPile 3: 7\n\nYour Turn\nChoose Pile: 3\nChoose Count: 6\n\nPiles:\nPile 0: 0\nPile 1: 3\nPile 2: 0\nPile 3: 1\n\nAI's Turn\nAI chose to take 1 object(s) from pile 3.\n\nPiles:\nPile 0: 0\nPile 1: 3\nPile 2: 0\nPile 3: 0\n\nYour Turn\nChoose Pile: 1\nChoose Count: 2\n\nPiles:\nPile 0: 0\nPile 1: 1\nPile 2: 0\nPile 3: 0\n\nAI's Turn\nAI chose to take 1 object(s) from pile 1.\n\nGAME OVER\nWinner is Human\nWe can see that it is very easy to win against the AI since it is playing randomly without using any optimized Q-values."
  },
  {
    "objectID": "projects/NimGame/NimGame.html#human-vs-trained-ai",
    "href": "projects/NimGame/NimGame.html#human-vs-trained-ai",
    "title": "2. Training an AI to play a game using reinforcement learning",
    "section": "4.2 Human Vs Trained AI",
    "text": "4.2 Human Vs Trained AI\nNow, let’s train our AI on 10,000 games and play against it.\n\n\nCode\ntrained_ai = train(10000)\n\n\nPlaying training game 1\nPlaying training game 2\nPlaying training game 3\nPlaying training game 4\nPlaying training game 5\nPlaying training game 6\nPlaying training game 7\nPlaying training game 8\nPlaying training game 9\nPlaying training game 10\n*\n*\n*\n*\n*\nPlaying training game 9991\nPlaying training game 9992\nPlaying training game 9993\nPlaying training game 9994\nPlaying training game 9995\nPlaying training game 9996\nPlaying training game 9997\nPlaying training game 9998\nPlaying training game 9999\nPlaying training game 10000\n\nDone training\n\n\nCode\nplay(trained_ai)\n\n\nPiles:\nPile 0: 1\nPile 1: 3\nPile 2: 5\nPile 3: 7\n\nAI's Turn\nAI chose to take 5 object(s) from pile 2.\n\nPiles:\nPile 0: 1\nPile 1: 3\nPile 2: 0\nPile 3: 7\n\nYour Turn\nChoose Pile: 1\nChoose Count: 2\n\nPiles:\nPile 0: 1\nPile 1: 1\nPile 2: 0\nPile 3: 7\n\nAI's Turn\nAI chose to take 6 object(s) from pile 3.\n\nPiles:\nPile 0: 1\nPile 1: 1\nPile 2: 0\nPile 3: 1\n\nYour Turn\nChoose Pile: 3\nChoose Count: 1\n\nPiles:\nPile 0: 1\nPile 1: 1\nPile 2: 0\nPile 3: 0\n\nAI's Turn\nAI chose to take 1 object(s) from pile 0.\n\nPiles:\nPile 0: 0\nPile 1: 1\nPile 2: 0\nPile 3: 0\n\nYour Turn\nChoose Pile: 1\nChoose Count: 1\n\nGAME OVER\nWinner is AI\nNow that we have trained the AI, we can see that it is quite challenging to beat the AI as it has gained the experience needed to make optimal moves and win the game."
  },
  {
    "objectID": "projects/MNIST/mnist.html",
    "href": "projects/MNIST/mnist.html",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "",
    "text": "In this project, we will build a classifier that takes an image of a handwritten digit and recognizes the digit present in the image. Specifically, we will look at a simple strategy for this problem known as the nearest neighbor(NN) classifier."
  },
  {
    "objectID": "projects/MNIST/mnist.html#dimensions-of-the-training-and-the-test-set",
    "href": "projects/MNIST/mnist.html#dimensions-of-the-training-and-the-test-set",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "2.1 Dimensions of the training and the test set",
    "text": "2.1 Dimensions of the training and the test set\n\n\nCode\n## Print out their dimensions\n\nprint(\"Training dataset dimensions: \", np.shape(train_data))\nprint(\"Number of training labels: \", len(train_labels), end='\\n\\n')\n\nprint(\"Testing dataset dimensions: \", np.shape(test_data))\nprint(\"Number of testing labels: \", len(test_labels))\n\n\nTraining dataset dimensions:  (7500, 784)\nNumber of training labels:  7500\n\nTesting dataset dimensions:  (1000, 784)\nNumber of testing labels:  1000\n\n\nEach data point, i.e., a handwritten digit image in the dataset, is composed of 784 pixels and is stored as a vector with 784 coordinates/dimensions, where each coordinate has a numeric value ranging from 0 to 255.\nLet us look at these numeric values by examining one of the images, say, the first image, in the dataset.\n\n\nCode\n# print out the the first data point in training data\n\ntrain_data[0] \n\n\narray([  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,  49., 138., 243., 255., 154.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   9., 197., 252.,\n       252., 253., 236., 161.,  50.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0., 130., 252., 227., 130., 190., 252., 252., 227.,\n        48.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 155., 236., 227.,\n        50.,   0.,   5.,  83., 252., 252., 137.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,  53., 253., 252., 130.,   0.,   0.,   0.,  26., 221.,\n       252., 242., 158.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 127., 255., 228.,\n        32.,   0.,   0.,   0.,   0., 185., 253., 253., 231.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0., 230., 253., 132.,   0.,   0.,   0.,   0.,   0.,\n       111., 252., 252., 230.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 230., 253.,\n        92.,   0.,   0.,   0.,   0.,   0., 153., 252., 252., 199.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0., 230., 253.,  92.,   0.,   0.,   0.,   0.,\n        17., 209., 252., 252.,  74.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0., 126.,\n       253., 196.,   0.,   0.,   0.,   0.,  99., 252., 252., 252.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0., 255., 253., 222.,  97.,  24.,\n        87., 212., 253., 253., 190.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0., 159., 252., 252., 252., 252., 253., 252., 252., 252., 137.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   7., 141., 183., 183.,\n       246., 215., 196., 252., 252., 137.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,  42.,  21.,  47., 252., 252.,\n       137.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,  47., 252., 252., 137.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  47., 253.,\n       253., 137.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,  47., 252., 252., 137.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,  47.,\n       252., 252., 137.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,  47., 252., 252., 137.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         5., 137., 252.,  85.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n         0.,   0.,   0.], dtype=float32)"
  },
  {
    "objectID": "projects/MNIST/mnist.html#compute-the-number-of-images-of-each-digit-in-the-dataset",
    "href": "projects/MNIST/mnist.html#compute-the-number-of-images-of-each-digit-in-the-dataset",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "2.2 Compute the number of images of each digit in the dataset",
    "text": "2.2 Compute the number of images of each digit in the dataset\n\n\nCode\n## Compute the number of images of each digit in the training ans test dataset\n\n\ntrain_digits, train_counts = np.unique(train_labels, return_counts=True)\nprint(\"Training set distribution:\")\nprint(dict(zip(train_digits, train_counts)), end='\\n\\n')\n\ntest_digits, test_counts = np.unique(test_labels, return_counts=True)\nprint(\"Test set distribution:\")\nprint(dict(zip(test_digits, test_counts)))\n\n\nTraining set distribution:\n{0: 750, 1: 750, 2: 750, 3: 750, 4: 750, 5: 750, 6: 750, 7: 750, 8: 750, 9: 750}\n\nTest set distribution:\n{0: 100, 1: 100, 2: 100, 3: 100, 4: 100, 5: 100, 6: 100, 7: 100, 8: 100, 9: 100}\n\n\nSo in the training set, we have 750 images of digits 0-9 each, totaling 7500 images. In the test set, we have 100 images of digits 0-9 each, with a total of 1000 images."
  },
  {
    "objectID": "projects/MNIST/mnist.html#view-the-first-data-point-in-the-training-set-and-test-set",
    "href": "projects/MNIST/mnist.html#view-the-first-data-point-in-the-training-set-and-test-set",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "3.1 View the first data point in the training set and test set",
    "text": "3.1 View the first data point in the training set and test set\nNow that we have defined a function for visualizing the image, let’s see it in action by applying it to the first data points of the dataset.\n\n\nCode\n## View the first data point in the training set\n\nvis_image(0, \"train\")\n\n\n\n\n\n            Label 9\n\n\n\n\nCode\n## Now view the first data point in the test set\n\nvis_image(0, \"test\")\n\n\n\n\n\n            Label 0"
  },
  {
    "objectID": "projects/MNIST/mnist.html#examples-of-computing-squared-euclidean-distance",
    "href": "projects/MNIST/mnist.html#examples-of-computing-squared-euclidean-distance",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "4.1 Examples of computing squared Euclidean distance",
    "text": "4.1 Examples of computing squared Euclidean distance\n\n\nCode\nprint('Examples:\\n')\n\n## Computing distances between digits in our training set.\n\nprint(f\"Distance from digit {train_labels[4]} to digit {train_labels[5]} in our training set: {squared_dist(train_data[4],train_data[5])}\")\n\nprint(f\"Distance from digit {train_labels[4]} to digit {train_labels[1]} in our training set: {squared_dist(train_data[4],train_data[1])}\")\n\nprint(f\"Distance from digit {train_labels[4]} to digit {train_labels[7]} in our training set: {squared_dist(train_data[4],train_data[7])}\")\n\n\nExamples:\n\nDistance from digit 7 to digit 1 in our training set: 5357193.0\nDistance from digit 7 to digit 2 in our training set: 12451684.0\nDistance from digit 7 to digit 7 in our training set: 5223403.0"
  },
  {
    "objectID": "projects/MNIST/mnist.html#compute-the-classification-time-of-nn",
    "href": "projects/MNIST/mnist.html#compute-the-classification-time-of-nn",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "6.1 Compute the classification time of NN",
    "text": "6.1 Compute the classification time of NN\nSince the nearest neighbor classifier goes through the entire training set of 7500 images, searching for the nearest neighbor image for every single test image in the dataset of 1000 images, we should not expect testing to be very fast.\n\n\nCode\n## Compute the classification time of NN classifier\n\nprint(f\"Classification time of NN classifier: {round(t_after - t_before, 2)} sec\")\n\n\nClassification time of NN classifier: 23.23 sec"
  },
  {
    "objectID": "projects/MNIST/mnist.html#compute-the-error-rate-of-nn",
    "href": "projects/MNIST/mnist.html#compute-the-error-rate-of-nn",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "6.2 Compute the error rate of NN",
    "text": "6.2 Compute the error rate of NN\n\n\nCode\n## Compute the error rate \n\nerr_positions = np.not_equal(test_predictions, test_labels)\nerror = float(np.sum(err_positions))/len(test_labels)\n\nprint(f\"Error rate of nearest neighbor classifier: {error * 100}%\")\n\n\nError rate of nearest neighbor classifier: 4.6%\n\n\nThe error rate of the NN classifier is 4.6%. This means that out of the 1000 points, NN misclassifies 46 of them. That’s not too bad for such a simple method."
  },
  {
    "objectID": "projects/MNIST/mnist.html#k-d-tree-algorithm",
    "href": "projects/MNIST/mnist.html#k-d-tree-algorithm",
    "title": "1. Nearest neighbor classifier for handwritten digit recognition",
    "section": "7.1 k-d tree algorithm",
    "text": "7.1 k-d tree algorithm\nThe key advantage of the k-d tree is its ability to significantly reduce the number of distance calculations needed during a nearest neighbor search by efficiently pruning regions of the search space. This algorithm is based on the triangle inequality, utilizing the fact that if point ‘a’ is significantly far from point ‘b,’ and point ‘b’ is in close proximity to point ‘c,’ we can infer that points ‘a’ and ‘c’ are also distant from each other without explicitly calculating their distance.\nThis way, the computational cost of a nearest neighbors search can be reduced to \\(O(dNlog(N))\\) or better.\n\n\nCode\n## Build nearest neighbor structure on training data\n\nt_before = time.time()\nkd_tree = KDTree(train_data)\nt_after = time.time()\n\n## Compute training time\nt_training = t_after - t_before\nprint(f\"Time to build data structure: {round(t_training, 2)} sec\")\n\n## Get nearest neighbor predictions on testing data\nt_before = time.time()\ntest_neighbors = np.squeeze(kd_tree.query(test_data, k=1, return_distance=False))\nkd_tree_predictions = train_labels[test_neighbors]\nt_after = time.time()\n\n## Compute testing time\nt_testing = t_after - t_before\nprint(f\"Time to classify test set: {round(t_testing, 2)} sec\", end = '\\n\\n')\n\n## total classification time\n\nprint(f\"Overall classification time of k-d tree algorithm: {round(t_training+t_testing, 2)} sec\")\n\n\n## Verify that the predictions are the same\nprint(\"Does k-d tree produce same predictions as NN classifier? \", np.array_equal(test_predictions, kd_tree_predictions))\n\n\nTime to build data structure: 0.52 sec\nTime to classify test set: 4.79 sec\n\nOverall classification time of k-d tree algorithm: 5.31 sec\nDoes k-d tree produce same predictions as NN classifier?  True\n\n\nWe can see that the baseline nearest neighbor model and the k-d tree algorithm produce the same predictions, but the key difference is that the k-d tree is significantly faster than the former."
  },
  {
    "objectID": "projects/MNIST/omnist.html",
    "href": "projects/MNIST/omnist.html",
    "title": "Nearest neighbor classifier for handwritten digit recognition",
    "section": "",
    "text": "In this project we will build a classifier that takes an image of a handwritten digit and recognizes the digit present in the image. Specifically, we will look at a simple strategy for this problem known as the nearest neighbor(NN) classifier.\nPlease click here for the detailed project."
  },
  {
    "objectID": "projects/MNIST/omnist.html#k-d-tree-algorithm",
    "href": "projects/MNIST/omnist.html#k-d-tree-algorithm",
    "title": "Nearest neighbor classifier for handwritten digit recognition",
    "section": "4.1 k-d tree algorithm",
    "text": "4.1 k-d tree algorithm\nThe key advantage of the k-d tree is its ability to significantly reduce the number of distance calculations needed during a nearest neighbor search by efficiently pruning regions of the search space. This algorithm is based on the triangle inequality, utilizing the fact that if point ‘a’ is significantly far from point ‘b,’ and point ‘b’ is in close proximity to point ‘c,’ we can infer that points ‘a’ and ‘c’ are also distant from each other without explicitly calculating their distance. This way, the computational cost of a nearest neighbors search can be reduced to \\(O(dNlog(N))\\) or better.\nAfter implementing k-d tree algorithm, we get a classification time of about 5-6 seconds, which is drastically less than baseline NN classifier."
  },
  {
    "objectID": "projects/ParseTrees/ParsetreesNnounphrases.html",
    "href": "projects/ParseTrees/ParsetreesNnounphrases.html",
    "title": "1. Generating parse trees and extracting noun phrases",
    "section": "",
    "text": "In Natural Language Processing (NLP), parsing refers to the process of analyzing a sentence to identify its grammatical structure. This is useful for a number of reasons, such as understanding sentence structure, resolving ambiguities in sentences, and better extraction of information from sentences.\nIn this project, we will work with the following English sentences and apply the context-free grammar (CFG) formalism to generate a parse tree or syntactic tree that represents the syntactic structure of the given sentences. Then, we will extract noun phrases from those sentences.\nSentences to analyze:"
  },
  {
    "objectID": "projects/ParseTrees/ParsetreesNnounphrases.html#cfg-rules",
    "href": "projects/ParseTrees/ParsetreesNnounphrases.html#cfg-rules",
    "title": "1. Generating parse trees and extracting noun phrases",
    "section": "1.1 CFG rules",
    "text": "1.1 CFG rules\nA rewriting rule in a CFG has the following form:\n𝐴 → 𝛼\nWhere: * 𝐴 is a non-terminal symbol and * 𝛼 is a string consisting of terminal and/or non-terminal symbols.\nNow, let’s define a concrete set of rules for generating terminal symbols and non-terminal symbols.\n\n1.1.1 Terminal symbols\nTerminal symbols represent the words in the sentence. The rules for generating these terminal symbols are defined in the global variable TERMINALS, which includes all the words of the given sentences to analyze. Notice that Adj is a nonterminal symbol that generates adjectives, Adv generates adverbs, Conj generates conjunctions, Det generates determiners, N generates nouns (spread across multiple lines for readability), P generates prepositions, and V generates verbs. The vertical bar | denotes all the terminal symbol alternatives for that particular non-terminal symbol.\n\n\nCode\nTERMINALS = \"\"\"\nAdj -&gt; \"country\" | \"dreadful\" | \"enigmatical\" | \"little\" | \"moist\" | \"red\"\nAdv -&gt; \"down\" | \"here\" | \"never\"\nConj -&gt; \"and\" | \"until\"\nDet -&gt; \"a\" | \"an\" | \"his\" | \"my\" | \"the\"\nN -&gt; \"armchair\" | \"companion\" | \"day\" | \"door\" | \"hand\" | \"he\" | \"himself\"\nN -&gt; \"holmes\" | \"home\" | \"i\" | \"mess\" | \"paint\" | \"palm\" | \"pipe\" | \"she\"\nN -&gt; \"smile\" | \"thursday\" | \"walk\" | \"we\" | \"word\" \nP -&gt; \"at\" | \"before\" | \"in\" | \"of\" | \"on\" | \"to\" \nV -&gt; \"arrived\" | \"came\" | \"chuckled\" | \"had\" | \"lit\" | \"said\" | \"sat\"\nV -&gt; \"smiled\" | \"tell\" | \"were\" \n\"\"\"\n\n\n\n\n1.1.2 Non-terminal symbols\nNon-terminal symbols are syntactic variables that represent sets of strings. Common non-terminals include parts of speech (e.g., noun, verb) and phrases (e.g., noun phrase, verb phrase). These symbols are defined in the global variable called NONTERMINALS and it contains all the rules for generating non-terminal symbols.\nThe description of symbols is as follows: S represents a complete sentence, NP represents a noun phrase, VP represents a verb phrase, PP represents a prepositional phrase, Det represents a determiner, and AP represents an adjective phrase. Each alternative separated by the vertical bar | represents a different way that a non-terminal can be replaced by a sequence of terminals and/or non-terminals. We can notice that all these rules are self-explanatory. For example, a rule like AP → Adj | Adj AP indicates that an adjective phrase can be formed either by an adjective or by an adjective followed by an adjective phrase.\n\n\nCode\nNONTERMINALS = \"\"\"\nS -&gt; NP VP | VP NP | S Conj S\n\nNP -&gt; N | Det N | NP PP | Det AP N\nVP -&gt; V | V NP | V PP | Adv VP | VP Adv\nAP -&gt; Adj | Adj AP\nPP -&gt; P NP\n\"\"\""
  }
]